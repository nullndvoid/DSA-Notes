/*
 * This source file was generated by the Gradle 'init' task
 */
package xyz.nullndvoid.dsa;

import java.util.*;

public class MaxHeap<T extends Comparable<T>> {
    private List<T> heap;
    int size;

    public MaxHeap() {
        heap = new ArrayList<>();
        size = 0;
    }

    public int left(int i) {
        return 2 * i + 1;
    }

    public int right(int i) {
        return 2 * i + 2;
    }

    public int parent(int i) {
        return (i - 1) / 2;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public void insert(T key) {
        heap.add(size, key);

        bubbleUp(size);

        size++;
    }

    /**
     * Bubbles up a node until in correct spot, swapping nodes as required.
     *
     * Time complexity: O(log n) as the tree is complete and loop runs at
     * most `depth` times.
     *
     * @param idx The index of the node to bubble up.
     */
    private void bubbleUp(int idx) {
        int i = idx;

        // Whilst not at root and whilst larger than its parent, shift the node up
        // (swap).
        while (i > 0 && (heap.get(i).compareTo(heap.get(parent(i))) > 0)) {
            Collections.swap(heap, i, parent(i));
            i = parent(i);
        }
    }

    /**
     * @return The maximum item in the heap. O(1) time complexity in all cases.
     */
    public T getMax() {
        return heap.get(0);
    }

    /** Deletes the highest priority element in the heap. */
    public void deleteMax() {
        // Swap the last node with the root.
        Collections.swap(heap, size - 1, 0);

        // Decrement size first, then bubble down.
        size--;

        // Finally, bubble down the root node.
        bubbleDown(0);

        heap.set(size, null);
    }

    /**
     * Bubbles down a node from `idx`, swapping with largest child node until
     * complete.
     *
     * Worst case time complexity of O(log n) since the tree is complete.
     *
     * @param idx The index of the node to bubble down from.
     */
    private void bubbleDown(int idx) {
        int i = idx;

        while (left(i) < size) {
            // Just a left child.
            if (right(i) >= size) {
                if (heap.get(i).compareTo(heap.get(left(i))) < 0) {
                    Collections.swap(heap, i, left(i));
                    i = left(i);
                } else {
                    break;
                }
            } else {
                // Two children, swap with largest.
                T left = heap.get(left(i));
                T right = heap.get(right(i));

                int nextI = (left.compareTo(right) > 0) ? left(i) : right(i);

                if (heap.get(i).compareTo(heap.get(nextI)) < 0) {
                    Collections.swap(heap, i, nextI);
                    i = nextI;
                } else {
                    return;
                }
            }
        }
    }

    /**
     * Deletes an arbitrary node with index `idx` from the heap.
     *
     * Worst case time complexity is O(log n) since the tree is complete.
     *
     * @param idx The index of the node to be deleted.
     */
    public void deleteNode(int idx) {
        if (idx == 0) {
            deleteMax();
            return;
        }

        Collections.swap(heap, idx, size - 1);

        size--;

        int parentIdx = parent(idx);

        T parentNode = heap.get(parentIdx);
        T thisNode = heap.get(idx);

        if (thisNode.compareTo(parentNode) > 0) {
            // Bubble up.
            bubbleUp(idx);
        } else {
            bubbleDown(idx);
        }

        heap.set(size - 1, null);
    }

    /**
     * Creates a heap from a list `arr`. Time complexity of O(n).
     * TO-DO: Remember explanation.
     *
     * @param arr The list to be heapified.
     */
    public MaxHeap(List<T> arr) {
        heap = new ArrayList<>(arr);
        size = arr.size();

        for (int i = arr.size() - 1; i >= 0; i--) {
            bubbleDown(i);
        }
    }

    /**
     * heapsort algorithm. O(n + nlogn) implies O(nlogn) time complexity.
     *
     * Space complexity is O(n) here since we have to make a mutable copy, but this
     * is typically done in-place without any Java fuckery.
     *
     * @param <T> A comparable type.
     * @param arr The array or list to be sorted.
     * @return A sorted list.
     */
    public static <T extends Comparable<T>> List<T> heapsort(List<T> arr) {
        List<T> mutableList = new ArrayList<>(arr);
        MaxHeap<T> heap = new MaxHeap<>(mutableList);

        // In-place sort: largest elements move to the end.
        for (int i = heap.size - 1; i > 0; i--) {
            Collections.swap(heap.heap, 0, i);
            heap.size--;
            heap.bubbleDown(0);
        }

        return heap.heap; // Now sorted in ascending order.
    }
}
